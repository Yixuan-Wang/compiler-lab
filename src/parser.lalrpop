use crate::front::ast::*;

grammar;

match {
    r"\s*" => {},
    r"//[^\n\r]*[\n\r]*" => {},
    r"/\*[^*]*(\*([^*/][^*]*)?)*\*/" => {},
    _
}

// r"//([^!\n\r][^\n\r]*[\n\r]*)+" => {},

Comma<T>: Vec<T> = {
    <mut v:(<T> ",")*> <e:T> => {
        v.push(e);
        v
    }
};

pub CompUnit: Vec<Item> = <Item*>;

Item: Item = {
    <f: Func> => Item { kind: ItemKind::Func(f) }
}

Func: Func = {
    <t:FUNC_TYPE> <i:IDENT> "(" ")" <b:Block> => {
        Func::new(i, t, b)
    }
}

Block: Block = "{" <Stmt*> "}" => Block(<>);

Stmt: Stmt = {
    UnitStmt,
    ExpStmt,
    BlockStmt,
    DeclStmt,
    AssignStmt,
    ReturnStmt,
}

UnitStmt: Stmt = ";" => Stmt { kind: StmtKind::Unit };

ExpStmt: Stmt = <Exp> ";" => Stmt { kind: StmtKind::Exp(<>) };

BlockStmt: Stmt = <Block> => Stmt { kind: StmtKind::Block(<>) };

DeclStmt: Stmt = Decl => Stmt { kind: StmtKind::Decl(<>) };

AssignStmt: Stmt = <LVal> "=" <Exp> ";" => Stmt { kind: StmtKind::Assign(<>) };

ReturnStmt: Stmt = {
    "return" <r:Exp> ";" => Stmt { kind: StmtKind::Return(Some(r)) },
    "return" ";" => Stmt { kind: StmtKind::Return(None)},
}

Decl: Vec<Decl> = {
    "const" <ty: VAL_TYPE> <v: Comma<ConstDef>> ";" => {
        v.into_iter().map(|(ident, constexp)| {
            Decl {
                ident,
                exp: Some(constexp),
                ty: Ty::new(&ty),
                kind: SymKind::Const,
            }
        }).collect()
    },
    <ty: VAL_TYPE> <v: Comma<VarDef>> ";" => {
        v.into_iter().map(|(ident, exp)| {
            Decl {
                ident,
                exp,
                ty: Ty::new(&ty),
                kind: SymKind::Var,
            }
        }).collect()
    },
}

ConstDef: (String, Exp) = <IDENT> "=" <ConstExp>;

VarDef: (String, Option<Exp>) = <IDENT> <("=" <VarExp>)?>;

LVal: LVal = IDENT => LVal(<>);

Exp: Exp = LOrExp => Exp(<>);

ConstExp: Exp = Exp;

VarExp: Exp = Exp;

PrimaryExp: PrimaryExp = {
    "(" <Exp> ")" => PrimaryExp::Exp(Box::new(<>)),
    LVal => PrimaryExp::LVal(<>),
    Number
}

Number: PrimaryExp = {
    r"[1-9][0-9]*|0" => PrimaryExp::literal(<>, 10, 0),
    r"0[0-7]+" => PrimaryExp::literal(<>, 8, 1),
    r"0[xX][0-9a-fA-F]+" => PrimaryExp::literal(<>, 16, 2),
}

UnaryExp: UnaryExp = {
    PrimaryExp => UnaryExp::Primary(<>),
    <o:UnaryOp> <e:UnaryExp> => UnaryExp::Unary(o, Box::new(e)),
    "+" <UnaryExp>,
}

UnaryOp: UnaryOp = {
    "-" => UnaryOp::Minus,
    "!" => UnaryOp::LNot,
}

MulExp: MulExp = {
    <UnaryExp> => MulExp::Unary(<>),
    <l:MulExp> <o:MulOp> <r:UnaryExp> => MulExp::Binary(Box::new(l), o, r),
}

MulOp: MulOp = {
    "*" => MulOp::Mul,
    "/" => MulOp::Div,
    "%" => MulOp::Mod,
}

AddExp: AddExp = {
    <MulExp> => AddExp::Unary(<>),
    <l:AddExp> <o:AddOp> <r:MulExp> => AddExp::Binary(Box::new(l), o, r),
}

AddOp: AddOp = {
    "+" => AddOp::Add,
    "-" => AddOp::Sub,
}

RelExp: RelExp = {
    <AddExp> => RelExp::Unary(<>),
    <l:RelExp> <o:RelOp> <r:AddExp> => RelExp::Binary(Box::new(l), o, r),
}

RelOp: RelOp = {
    "<" => RelOp::Lt,
    ">" => RelOp::Gt,
    "<=" => RelOp::Le,
    ">=" => RelOp::Ge,
}

EqExp: EqExp = {
    <RelExp> => EqExp::Unary(<>),
    <l:EqExp> <o:EqOp> <r:RelExp> => EqExp::Binary(Box::new(l), o, r),
}

EqOp: EqOp = {
    "==" => EqOp::Eq,
    "!=" => EqOp::Ne,
}

LAndExp: LAndExp = {
    <EqExp> => LAndExp::Unary(<>),
    <l:LAndExp> "&&" <r:EqExp> => LAndExp::Binary(Box::new(l), r),
}

LOrExp: LOrExp = {
    <LAndExp> => LOrExp::Unary(<>),
    <l:LOrExp> "||" <r:LAndExp> => LOrExp::Binary(Box::new(l), r),
}

IDENT: String = r"[A-Za-z_][A-Za-z0-9_]*" => <>.to_string();

FUNC_TYPE: String = "int" => <>.to_string();

VAL_TYPE: String = "int" => <>.to_string();
