use crate::front::ast::*;

grammar;

match {
    r"\s*" => {},
    r"//[^\n\r]*[\n\r]*" => {},
    r"/\*[^*]*(\*([^*/][^*]*)?)*\*/" => {},
    _
}

// r"//([^!\n\r][^\n\r]*[\n\r]*)+" => {},

pub CompUnit: Vec<Item> = <Item*>;

Item: Item = {
    <f: Func> => Item { kind: ItemKind::Func(f) }
}

Func: Func = {
    <t:FUNC_TYPE> <i:IDENT> "(" ")" "{" <b:Block> "}" => {
        Func::new(i, t, b)
    }
}

Block: Vec<Stmt> = <Stmt*>;

Stmt: Stmt = {
    ReturnStmt,
}

ReturnStmt: Stmt = {
    "return" <r:Exp> ";" => Stmt { kind: StmtKind::Return(r) }
}

Exp: Exp = UnaryExp => Exp(<>);

PrimaryExp: PrimaryExp = {
    "(" <Exp> ")" => PrimaryExp::Exp(Box::new(<>)),
    r"(-|\+)?([1-9][0-9]*|0)" => PrimaryExp::literal(<>, 10, 0),
    r"0[0-7]+" => PrimaryExp::literal(<>, 8, 1),
    r"0[xX][0-9a-fA-F]+" => PrimaryExp::literal(<>, 16, 2),
}

UnaryExp: UnaryExp = {
    PrimaryExp => UnaryExp::Primary(<>),
    <o:UnaryOp> <e:UnaryExp> => UnaryExp::Unary(o, Box::new(e)),
    "+" <UnaryExp>,
}

UnaryOp: UnaryOp = {
    "-" => UnaryOp::Minus,
    "!" => UnaryOp::LNot,
}

IDENT: String = r"[A-Za-z_][A-Za-z0-9_]+" => <>.to_string();

FUNC_TYPE: String = "int" => <>.to_string();
